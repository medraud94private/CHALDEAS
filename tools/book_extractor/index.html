<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>CHALDEAS Book Extractor v2</title>
    <style>
        * { box-sizing: border-box; margin: 0; padding: 0; }
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: #1a1a2e;
            color: #eee;
            padding: 20px;
            min-height: 100vh;
        }
        .container { max-width: 1600px; margin: 0 auto; }

        header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
            padding-bottom: 15px;
            border-bottom: 1px solid #333;
        }
        h1 { color: #ffd700; font-size: 1.5rem; }
        h1 small { color: #888; font-size: 0.7rem; font-weight: normal; }

        .status-bar {
            display: flex;
            gap: 12px;
            font-size: 0.8rem;
            align-items: center;
        }
        .status-item {
            padding: 5px 12px;
            border-radius: 15px;
            background: #2a2a4a;
            white-space: nowrap;
        }
        .status-item.online { background: #1a4a1a; }
        .status-item.offline { background: #4a1a1a; }

        .speed-control {
            display: flex;
            gap: 3px;
            padding: 3px 5px;
            background: #2a2a4a;
            border-radius: 15px;
            align-items: center;
        }
        .speed-btn {
            width: 28px;
            height: 24px;
            border: none;
            border-radius: 10px;
            background: transparent;
            cursor: pointer;
            font-size: 13px;
            transition: all 0.2s;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        .speed-btn:hover { background: #3a3a5a; }
        .speed-btn.active { background: #ffd700; }

        /* Main Tabs */
        .main-tabs {
            display: flex;
            gap: 5px;
            margin-bottom: 15px;
            border-bottom: 2px solid #2a2a4a;
            padding-bottom: 10px;
        }
        .main-tab {
            padding: 10px 20px;
            background: #2a2a4a;
            border: none;
            border-radius: 5px 5px 0 0;
            color: #888;
            cursor: pointer;
            font-size: 0.9rem;
            transition: all 0.2s;
        }
        .main-tab.active {
            background: #3a3a6a;
            color: #ffd700;
        }
        .main-tab:hover { background: #3a3a5a; }
        .main-tab .badge {
            font-size: 0.7rem;
            padding: 2px 6px;
            border-radius: 10px;
            margin-left: 5px;
            background: #4a4a6a;
        }
        .main-tab.active .badge { background: #ffd700; color: #1a1a2e; }

        /* Sub Tabs */
        .tabs {
            display: flex;
            gap: 10px;
            margin-bottom: 15px;
        }
        .tab {
            padding: 8px 16px;
            background: #2a2a4a;
            border: none;
            border-radius: 5px;
            color: #888;
            cursor: pointer;
            font-size: 0.85rem;
        }
        .tab.active {
            background: #3a3a6a;
            color: #ffd700;
        }
        .tab:hover { background: #3a3a5a; }

        .grid {
            display: grid;
            grid-template-columns: 350px 1fr 380px;
            gap: 20px;
            height: calc(100vh - 200px);
        }

        .panel {
            background: #16213e;
            border-radius: 8px;
            padding: 15px;
            overflow-y: auto;
        }
        .panel h2 {
            font-size: 0.9rem;
            color: #888;
            margin-bottom: 15px;
            text-transform: uppercase;
            letter-spacing: 1px;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        .panel h2 span { color: #ffd700; font-size: 0.8rem; }

        /* Category Group */
        .category-group {
            margin-bottom: 20px;
        }
        .category-group h3 {
            font-size: 0.75rem;
            color: #ffd700;
            margin-bottom: 8px;
            padding: 6px 10px;
            background: rgba(255,215,0,0.1);
            border-radius: 4px;
            display: flex;
            justify-content: space-between;
            cursor: pointer;
        }
        .category-group h3:hover { background: rgba(255,215,0,0.15); }
        .category-group h3 .count { color: #888; }
        .category-group.collapsed .book-list { display: none; }

        .book-item {
            padding: 8px 10px;
            margin-bottom: 4px;
            background: #1a1a2e;
            border-radius: 4px;
            cursor: pointer;
            transition: all 0.2s;
            display: flex;
            justify-content: space-between;
            align-items: center;
            font-size: 0.8rem;
        }
        .book-item:hover { background: #2a2a4e; }
        .book-item.selected { background: #2a3a5e; border-left: 3px solid #ffd700; }
        .book-item.done { opacity: 0.7; }
        .book-item.extracting { border-left: 3px solid #4a9; }

        .book-title {
            flex: 1;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
            margin-right: 10px;
        }

        .book-status {
            font-size: 0.6rem;
            padding: 2px 6px;
            border-radius: 3px;
            flex-shrink: 0;
        }
        .book-status.done { background: #1a4a1a; color: #6f6; }
        .book-status.pending { background: #333; color: #888; }
        .book-status.extracting { background: #4a3a1a; color: #fa0; }
        .book-status.matched { background: #1a3a4a; color: #6cf; }

        /* Book Detail */
        .book-detail { padding: 15px; }
        .book-detail h3 {
            font-size: 1.1rem;
            color: #ffd700;
            margin-bottom: 10px;
            line-height: 1.4;
        }
        .book-meta {
            font-size: 0.8rem;
            color: #888;
            margin-bottom: 15px;
            padding: 10px;
            background: #1a1a2e;
            border-radius: 5px;
        }
        .book-meta div { margin-bottom: 5px; }
        .book-meta label { color: #666; }

        .action-buttons {
            display: flex;
            gap: 10px;
            margin-bottom: 20px;
            flex-wrap: wrap;
        }
        button {
            padding: 10px 20px;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            font-size: 0.85rem;
            transition: all 0.2s;
        }
        .btn-primary { background: #ffd700; color: #1a1a2e; font-weight: bold; }
        .btn-primary:hover { background: #ffed4a; }
        .btn-primary:disabled { background: #666; cursor: not-allowed; }
        .btn-secondary { background: #3a3a5a; color: #ccc; }
        .btn-secondary:hover { background: #4a4a6a; }
        .btn-danger { background: #c44; color: #fff; }
        .btn-danger:hover { background: #e55; }
        .btn-match { background: #4a9; color: #fff; }
        .btn-match:hover { background: #5ba; }

        /* Progress */
        .progress-container { margin-bottom: 20px; }
        .progress-bar {
            height: 24px;
            background: #2a2a4a;
            border-radius: 12px;
            overflow: hidden;
        }
        .progress-fill {
            height: 100%;
            background: linear-gradient(90deg, #4a9, #6cf);
            transition: width 0.3s;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 0.7rem;
            color: #fff;
            font-weight: bold;
        }
        .progress-text {
            font-size: 0.8rem;
            color: #888;
            margin-top: 8px;
            text-align: center;
        }

        /* Content Preview */
        .content-preview {
            background: #1a1a2e;
            padding: 15px;
            border-radius: 5px;
            font-size: 0.75rem;
            line-height: 1.6;
            max-height: 300px;
            overflow-y: auto;
            white-space: pre-wrap;
            color: #aaa;
        }

        /* Results Panel */
        .results-section { margin-bottom: 20px; }
        .results-section h4 {
            font-size: 0.8rem;
            color: #888;
            margin-bottom: 8px;
            display: flex;
            justify-content: space-between;
        }
        .results-section h4 span { color: #ffd700; }

        .entity-list {
            background: #1a1a2e;
            border-radius: 5px;
            padding: 10px;
            max-height: 180px;
            overflow-y: auto;
            font-size: 0.75rem;
            line-height: 1.8;
        }
        .entity-item {
            display: inline-block;
            margin: 2px 4px 2px 0;
            padding: 2px 8px;
            background: #2a3a5e;
            border-radius: 3px;
        }
        .entity-item.matched { background: #1a4a3a; }
        .entity-item.new { background: #4a3a1a; }
        .entity-item.merged { background: #3a1a4a; }

        .empty-state {
            text-align: center;
            color: #555;
            padding: 40px 20px;
            font-size: 0.85rem;
        }

        /* Stats */
        .stats-grid {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 10px;
            margin-bottom: 20px;
        }
        .stat-box {
            background: #1a1a2e;
            padding: 15px 10px;
            border-radius: 5px;
            text-align: center;
        }
        .stat-value { font-size: 1.4rem; color: #ffd700; }
        .stat-label { font-size: 0.65rem; color: #666; margin-top: 5px; }

        /* Summary Stats */
        .summary-stats {
            display: flex;
            gap: 20px;
            margin-bottom: 15px;
            font-size: 0.75rem;
            color: #888;
        }
        .summary-stats span { color: #ffd700; }

        /* Queue Panel */
        .queue-panel {
            background: linear-gradient(135deg, #1a2a4a 0%, #16213e 100%);
            border: 1px solid #2a3a5a;
            border-radius: 10px;
            padding: 15px 20px;
            margin-bottom: 20px;
        }
        .queue-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        .queue-title {
            display: flex;
            align-items: center;
            gap: 10px;
            font-size: 1rem;
            font-weight: bold;
        }
        .queue-icon { color: #ffd700; }
        .queue-status {
            font-size: 0.7rem;
            padding: 3px 10px;
            border-radius: 12px;
            background: #333;
            color: #888;
        }
        .queue-status.running { background: #1a4a1a; color: #6f6; }
        .queue-status.paused { background: #4a4a1a; color: #fa0; }

        .queue-controls {
            display: flex;
            gap: 10px;
            align-items: center;
        }
        .queue-controls select {
            padding: 8px 12px;
            border-radius: 5px;
            background: #2a2a4a;
            border: 1px solid #3a3a5a;
            color: #eee;
            font-size: 0.8rem;
        }
        .btn-queue {
            padding: 8px 16px;
            border: none;
            border-radius: 5px;
            font-size: 0.8rem;
            cursor: pointer;
            font-weight: bold;
        }
        .btn-queue { background: #ffd700; color: #1a1a2e; }
        .btn-queue:hover { background: #ffed4a; }
        .btn-queue.btn-pause { background: #fa0; color: #1a1a2e; }
        .btn-queue.btn-stop { background: #c44; color: #fff; }
        .btn-queue:disabled { background: #666; cursor: not-allowed; }

        .queue-progress {
            margin-top: 15px;
        }
        .queue-progress-bar {
            height: 8px;
            background: #2a2a4a;
            border-radius: 4px;
            overflow: hidden;
        }
        .queue-progress-fill {
            height: 100%;
            background: linear-gradient(90deg, #4a9, #6cf);
            transition: width 0.5s;
        }
        .queue-progress-info {
            display: flex;
            justify-content: space-between;
            margin-top: 8px;
            font-size: 0.75rem;
            color: #888;
        }
        .queue-progress-info span:first-child { color: #ffd700; }

        /* Chunk Progress */
        .chunk-progress {
            margin-top: 10px;
            padding: 10px;
            background: #1a1a2e;
            border-radius: 5px;
        }
        .chunk-progress-bar {
            height: 6px;
            background: #2a2a4a;
            border-radius: 3px;
            overflow: hidden;
        }
        .chunk-progress-fill {
            height: 100%;
            background: linear-gradient(90deg, #fa0, #f60);
            transition: width 0.3s;
        }
        .chunk-info {
            display: flex;
            justify-content: space-between;
            font-size: 0.7rem;
            margin-top: 5px;
            color: #888;
        }
        .chunk-info .current { color: #fa0; }

        /* Stats Modal */
        .modal-overlay {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0,0,0,0.8);
            z-index: 1000;
            justify-content: center;
            align-items: center;
        }
        .modal-overlay.active { display: flex; }
        .modal {
            background: #16213e;
            border-radius: 10px;
            width: 90%;
            max-width: 1000px;
            max-height: 85vh;
            overflow-y: auto;
            padding: 20px;
        }
        .modal-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
            padding-bottom: 15px;
            border-bottom: 1px solid #333;
        }
        .modal-header h2 { color: #ffd700; font-size: 1.2rem; }
        .modal-close {
            background: none;
            border: none;
            color: #888;
            font-size: 1.5rem;
            cursor: pointer;
        }
        .modal-close:hover { color: #fff; }

        /* Stats Grid */
        .stats-overview {
            display: grid;
            grid-template-columns: repeat(4, 1fr);
            gap: 15px;
            margin-bottom: 20px;
        }
        .stats-card {
            background: #1a1a2e;
            padding: 15px;
            border-radius: 8px;
            text-align: center;
        }
        .stats-card .value { font-size: 1.8rem; color: #ffd700; }
        .stats-card .label { font-size: 0.7rem; color: #666; margin-top: 5px; }
        .stats-card.good .value { color: #6f6; }
        .stats-card.warn .value { color: #fa0; }
        .stats-card.bad .value { color: #f66; }

        /* History Table */
        .history-table {
            width: 100%;
            border-collapse: collapse;
            font-size: 0.75rem;
        }
        .history-table th {
            background: #1a1a2e;
            padding: 10px 8px;
            text-align: left;
            color: #888;
            border-bottom: 1px solid #333;
        }
        .history-table td {
            padding: 8px;
            border-bottom: 1px solid #2a2a4a;
        }
        .history-table tr:hover { background: #1a2a4a; }
        .speed-indicator {
            display: inline-block;
            width: 8px;
            height: 8px;
            border-radius: 50%;
            margin-right: 5px;
        }
        .speed-fast { background: #6f6; }
        .speed-medium { background: #fa0; }
        .speed-slow { background: #f66; }

        /* Stats Button */
        .btn-stats {
            padding: 5px 10px;
            background: #3a3a5a;
            border: none;
            border-radius: 5px;
            color: #888;
            cursor: pointer;
            font-size: 0.75rem;
        }
        .btn-stats:hover { background: #4a4a6a; color: #ffd700; }

        /* Matching Panel */
        .match-result-item {
            padding: 10px;
            margin-bottom: 8px;
            background: #1a1a2e;
            border-radius: 5px;
            border-left: 3px solid #4a9;
        }
        .match-result-item.new { border-left-color: #fa0; }
        .match-result-item.merged { border-left-color: #a4f; }
        .match-result-item .name { font-weight: bold; color: #ffd700; }
        .match-result-item .details { font-size: 0.75rem; color: #888; margin-top: 4px; }
        .match-result-item .method { font-size: 0.65rem; padding: 2px 6px; border-radius: 3px; background: #2a3a5a; }

        /* Duplicates Panel */
        .dup-item {
            padding: 12px;
            margin-bottom: 8px;
            background: #1a1a2e;
            border-radius: 5px;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        .dup-item .qid { font-weight: bold; color: #6cf; font-family: monospace; }
        .dup-item .count { color: #fa0; font-size: 1.2rem; font-weight: bold; }
        .dup-item .names { font-size: 0.75rem; color: #888; margin-top: 4px; }
        .dup-item .btn-merge {
            padding: 6px 12px;
            background: #4a9;
            border: none;
            border-radius: 4px;
            color: #fff;
            cursor: pointer;
            font-size: 0.75rem;
        }
        .dup-item .btn-merge:hover { background: #5ba; }

        /* Tab Content */
        .tab-content { display: none; }
        .tab-content.active { display: block; }

        /* Auto Tabs */
        .auto-tabs {
            display: flex;
            gap: 5px;
            margin-bottom: 15px;
            padding-bottom: 10px;
            border-bottom: 1px solid #2a3a5a;
            align-items: center;
        }
        .auto-tab {
            padding: 8px 16px;
            background: #2a2a4a;
            border: none;
            border-radius: 5px;
            color: #888;
            cursor: pointer;
            font-size: 0.8rem;
            transition: all 0.2s;
        }
        .auto-tab.active {
            background: linear-gradient(135deg, #3a4a6a 0%, #2a3a5a 100%);
            color: #ffd700;
        }
        .auto-tab:hover { background: #3a3a5a; }
        .auto-badge {
            font-size: 0.65rem;
            padding: 2px 6px;
            border-radius: 10px;
            background: #4a4a6a;
            margin-left: 5px;
        }
        .auto-tab.active .auto-badge { background: #ffd700; color: #1a1a2e; }

        .auto-content { display: none; }
        .auto-content.active { display: block; }

        .model-info {
            margin-left: auto;
            font-size: 0.75rem;
            color: #666;
            padding: 5px 12px;
            background: #1a1a2e;
            border-radius: 5px;
        }
        .model-label { color: #888; }
        #currentModelInfo { color: #6cf; font-family: monospace; }

        .model-hint {
            font-size: 0.7rem;
            color: #666;
            margin-left: 10px;
        }
    </style>
</head>
<body>
    <div class="container">
        <header>
            <h1>CHALDEAS Book Extractor <small>v2.1 - Entity Matching</small></h1>
            <div class="status-bar">
                <div class="status-item" id="zimStatus">ZIM: checking...</div>
                <div class="status-item" id="ollamaStatus">Ollama: checking...</div>
                <div class="status-item" id="modelStatus">Model: -</div>
                <div class="speed-control">
                    <button class="speed-btn" data-speed="quiet" title="Quiet (CPU only)">&#128263;</button>
                    <button class="speed-btn" data-speed="low" title="Low (10 layers)">&#128034;</button>
                    <button class="speed-btn" data-speed="medium" title="Medium (20 layers) ~5/min">&#128694;</button>
                    <button class="speed-btn" data-speed="high" title="High (30 layers) ~4.5/min">&#128640;</button>
                    <button class="speed-btn" data-speed="turbo" title="Turbo (50 layers) ~4/min">&#9889;</button>
                </div>
            </div>
        </header>

        <!-- Auto Processing Panel -->
        <div class="queue-panel" id="queuePanel">
            <div class="auto-tabs">
                <button class="auto-tab active" onclick="switchAutoTab('extraction')" data-tab="extraction">
                    &#128218; Auto Extraction
                </button>
                <button class="auto-tab" onclick="switchAutoTab('matching')" data-tab="matching">
                    &#128279; Auto Matching <span class="auto-badge" id="unmatchedBadge">0</span>
                </button>
                <button class="auto-tab" onclick="switchAutoTab('duplicates')" data-tab="duplicates">
                    &#128260; Auto Duplicates <span class="auto-badge" id="dupBadge">0</span>
                </button>
                <div class="model-info" id="modelInfoPanel">
                    <span class="model-label">Model:</span>
                    <span id="currentModelInfo">-</span>
                </div>
            </div>

            <!-- Extraction Tab -->
            <div class="auto-content active" id="autoExtractionContent">
                <div class="queue-header">
                    <div class="queue-title">
                        <span class="queue-status" id="queueStatusBadge">Stopped</span>
                        <span class="model-hint">Ollama llama3.1:8b (local, free)</span>
                    </div>
                    <div class="queue-controls">
                        <select id="modelSelect">
                            <option value="ollama">Ollama llama3.1:8b (Free)</option>
                            <option value="gpt-5-mini">GPT-5-mini (~$38)</option>
                            <option value="gpt-5.1-chat-latest">GPT-5.1 (~$190)</option>
                        </select>
                        <button class="btn-queue" id="queueStartBtn" onclick="startQueue()">Start All</button>
                        <button class="btn-queue btn-pause" id="queuePauseBtn" onclick="togglePause()" style="display:none">Pause</button>
                        <button class="btn-queue btn-stop" id="queueStopBtn" onclick="stopQueue()" style="display:none">Stop</button>
                    </div>
                </div>
                <div class="queue-progress" id="queueProgress" style="display:none">
                    <div class="queue-progress-bar">
                        <div class="queue-progress-fill" id="queueProgressFill" style="width:0%"></div>
                    </div>
                    <div class="queue-progress-info">
                        <span id="queueProgressText">0 / 0</span>
                        <span id="queueCurrentBook">-</span>
                        <span id="queueTimeInfo">-</span>
                    </div>
                    <div class="chunk-progress" id="chunkProgress" style="display:none">
                        <div class="chunk-progress-bar">
                            <div class="chunk-progress-fill" id="chunkProgressFill" style="width:0%"></div>
                        </div>
                        <div class="chunk-info">
                            <span class="current" id="chunkText">Chunk 0 / 0</span>
                            <span id="chunkSpeed">-</span>
                            <span id="bookElapsed">-</span>
                        </div>
                    </div>
                </div>
            </div>

            <!-- Matching Tab -->
            <div class="auto-content" id="autoMatchingContent">
                <div class="queue-header">
                    <div class="queue-title">
                        <span class="queue-status" id="matchingStatusBadge">Stopped</span>
                        <span class="model-hint">OpenAI text-embedding-3-small + gpt-5-mini</span>
                    </div>
                    <div class="queue-controls">
                        <button class="btn-queue btn-match" id="matchingStartBtn" onclick="startAutoMatching()">Match All Unmatched</button>
                        <button class="btn-queue btn-pause" id="matchingPauseBtn" onclick="toggleAutoMatching()" style="display:none">Pause</button>
                        <button class="btn-queue btn-stop" id="matchingStopBtn" onclick="stopAutoMatching()" style="display:none">Stop</button>
                    </div>
                </div>
                <div class="queue-progress" id="matchingProgress" style="display:none">
                    <div class="queue-progress-bar">
                        <div class="queue-progress-fill" id="matchingProgressFill" style="width:0%"></div>
                    </div>
                    <div class="queue-progress-info">
                        <span id="matchingProgressText">0 / 0 books</span>
                        <span id="matchingCurrentBook">-</span>
                        <span id="matchingTimeInfo">-</span>
                    </div>
                </div>
            </div>

            <!-- Duplicates Tab -->
            <div class="auto-content" id="autoDuplicatesContent">
                <div class="queue-header">
                    <div class="queue-title">
                        <span class="queue-status" id="dupStatusBadge">Stopped</span>
                        <span class="model-hint">Wikidata QID merge (DB only, free)</span>
                    </div>
                    <div class="queue-controls">
                        <button class="btn-queue" id="dupStartBtn" onclick="startAutoDuplicates()" style="background:#a4f;">Merge All Duplicates</button>
                        <button class="btn-queue btn-pause" id="dupPauseBtn" onclick="toggleAutoDuplicates()" style="display:none">Pause</button>
                        <button class="btn-queue btn-stop" id="dupStopBtn" onclick="stopAutoDuplicates()" style="display:none">Stop</button>
                    </div>
                </div>
                <div class="queue-progress" id="dupProgress" style="display:none">
                    <div class="queue-progress-bar" style="background:#2a2a4a;">
                        <div class="queue-progress-fill" id="dupProgressFill" style="width:0%; background:linear-gradient(90deg, #a4f, #f4a);"></div>
                    </div>
                    <div class="queue-progress-info">
                        <span id="dupProgressText">0 / 0 QIDs</span>
                        <span id="dupCurrentQid">-</span>
                        <span id="dupTimeInfo">-</span>
                    </div>
                </div>
            </div>
        </div>

        <div class="summary-stats">
            <div>Total Books: <span id="totalBooks">-</span></div>
            <div>Extracted: <span id="totalExtracted">-</span></div>
            <div>Duplicates: <span id="totalDuplicates">-</span></div>
            <button class="btn-stats" onclick="openStats()">&#128202; Statistics</button>
        </div>

        <!-- Main Tabs -->
        <div class="main-tabs">
            <button class="main-tab active" onclick="switchMainTab('extraction')">&#128218; Extraction</button>
            <button class="main-tab" onclick="switchMainTab('matching')">&#128279; Matching <span class="badge" id="matchingBadge">0</span></button>
            <button class="main-tab" onclick="switchMainTab('duplicates')">&#128260; Duplicates <span class="badge" id="duplicatesBadge">0</span></button>
        </div>

        <!-- EXTRACTION TAB -->
        <div id="extractionTab" class="tab-content active">
            <div class="tabs">
                <button class="tab active" onclick="switchTab('category')">By Category</button>
                <button class="tab" onclick="switchTab('servant')">By Servant</button>
            </div>

            <div class="grid">
                <!-- Book List -->
                <div class="panel" id="bookListPanel">
                    <h2>Books <span id="bookCount">0</span></h2>
                    <div id="bookList">Loading...</div>
                </div>

                <!-- Book Detail -->
                <div class="panel">
                    <h2>Detail</h2>
                    <div id="bookDetail">
                        <div class="empty-state">Select a book from the list to view details and start extraction</div>
                    </div>
                </div>

                <!-- Results -->
                <div class="panel">
                    <h2>Extraction Results</h2>
                    <div id="resultsPanel">
                        <div class="empty-state">Results will appear here after extraction</div>
                    </div>
                </div>
            </div>
        </div>

        <!-- MATCHING TAB -->
        <div id="matchingTab" class="tab-content">
            <div class="grid">
                <!-- Extracted Books -->
                <div class="panel">
                    <h2>Extracted Books <span id="extractedCount">0</span></h2>
                    <div id="extractedList">Loading...</div>
                </div>

                <!-- Matching Detail -->
                <div class="panel">
                    <h2>Matching</h2>
                    <div id="matchingDetail">
                        <div class="empty-state">Select an extracted book to start entity matching</div>
                    </div>
                </div>

                <!-- Match Results -->
                <div class="panel">
                    <h2>Match Results</h2>
                    <div id="matchResultsPanel">
                        <div class="empty-state">Match results will appear here</div>
                    </div>
                </div>
            </div>
        </div>

        <!-- DUPLICATES TAB -->
        <div id="duplicatesTab" class="tab-content">
            <div class="grid" style="grid-template-columns: 1fr 1fr;">
                <!-- Duplicate Status -->
                <div class="panel">
                    <h2>Duplicate Status</h2>
                    <div id="duplicateStatus">
                        <div class="stats-grid">
                            <div class="stat-box">
                                <div class="stat-value" id="dupTotal">-</div>
                                <div class="stat-label">Total Persons</div>
                            </div>
                            <div class="stat-box">
                                <div class="stat-value" id="dupQids">-</div>
                                <div class="stat-label">Duplicate QIDs</div>
                            </div>
                            <div class="stat-box">
                                <div class="stat-value" id="dupMerged">-</div>
                                <div class="stat-label">Merged Aliases</div>
                            </div>
                        </div>
                        <h4 style="color:#888; margin: 15px 0 10px;">Recent Merges</h4>
                        <div id="recentMerges"></div>
                    </div>
                </div>

                <!-- Top Duplicates -->
                <div class="panel">
                    <h2>Top Duplicates <button class="btn-stats" onclick="loadDuplicates()" style="margin-left:auto;">&#8635; Refresh</button></h2>
                    <div id="topDuplicates">Loading...</div>
                </div>
            </div>
        </div>
    </div>

    <!-- Statistics Modal -->
    <div class="modal-overlay" id="statsModal" onclick="closeStatsModal(event)">
        <div class="modal" onclick="event.stopPropagation()">
            <div class="modal-header">
                <h2>&#128202; Extraction Statistics</h2>
                <button class="modal-close" onclick="closeStats()">&times;</button>
            </div>
            <div id="statsContent">Loading...</div>
        </div>
    </div>

    <script>
        let currentBook = null;
        let currentMatchBook = null;
        let books = {};
        let pollingInterval = null;
        let currentTab = 'category';
        let currentMainTab = 'extraction';

        // ============ API Calls ============
        async function fetchBooks() {
            const resp = await fetch('/api/books');
            books = await resp.json();
            updateSummary();
            renderBookList();
        }

        async function checkOllama() {
            try {
                const resp = await fetch('/api/ollama/status');
                const data = await resp.json();
                const statusEl = document.getElementById('ollamaStatus');
                const modelEl = document.getElementById('modelStatus');

                if (data.status === 'online') {
                    statusEl.textContent = 'Ollama: Online';
                    statusEl.className = 'status-item online';
                    modelEl.textContent = `Model: ${data.current_model.split(':')[0]}`;
                } else {
                    statusEl.textContent = 'Ollama: Offline';
                    statusEl.className = 'status-item offline';
                }
            } catch (e) {
                document.getElementById('ollamaStatus').textContent = 'Ollama: Error';
                document.getElementById('ollamaStatus').className = 'status-item offline';
            }
        }

        async function checkZim() {
            try {
                const resp = await fetch('/api/zim/status');
                const data = await resp.json();
                const statusEl = document.getElementById('zimStatus');

                if (data.status === 'loaded') {
                    statusEl.textContent = `ZIM: ${(data.article_count/1000).toFixed(0)}K books`;
                    statusEl.className = 'status-item online';
                } else {
                    statusEl.textContent = 'ZIM: Not Loaded';
                    statusEl.className = 'status-item offline';
                }
            } catch (e) {
                document.getElementById('zimStatus').textContent = 'ZIM: Error';
                document.getElementById('zimStatus').className = 'status-item offline';
            }
        }

        async function startExtraction(bookId, zimPath, title) {
            const resp = await fetch('/api/extract/start', {
                method: 'POST',
                headers: {'Content-Type': 'application/json'},
                body: JSON.stringify({book_id: bookId, zim_path: zimPath, title})
            });
            const data = await resp.json();
            if (data.status === 'started') {
                startPolling(bookId);
            }
            return data;
        }

        async function cancelExtraction(bookId) {
            await fetch(`/api/extract/cancel/${bookId}`, {method: 'POST'});
            stopPolling();
            fetchBooks();
        }

        async function getExtractionStatus(bookId) {
            const resp = await fetch(`/api/extract/status/${bookId}`);
            return await resp.json();
        }

        async function getResults(bookId) {
            const resp = await fetch(`/api/results/${bookId}`);
            return await resp.json();
        }

        async function getContentPreview(zimPath) {
            const resp = await fetch(`/api/zim/content/${encodeURIComponent(zimPath)}`);
            return await resp.json();
        }

        // ============ Matching API ============
        async function startMatching(bookId) {
            const resp = await fetch(`/api/match/start/${bookId}`, {method: 'POST'});
            return await resp.json();
        }

        async function getMatchStatus(bookId) {
            const resp = await fetch(`/api/match/status/${bookId}`);
            return await resp.json();
        }

        async function getMatchResults(bookId) {
            const resp = await fetch(`/api/match/results/${bookId}`);
            return await resp.json();
        }

        async function getDuplicateStatus() {
            const resp = await fetch('/api/duplicates/status');
            return await resp.json();
        }

        async function getTopDuplicates() {
            const resp = await fetch('/api/duplicates/top');
            return await resp.json();
        }

        async function mergeDuplicate(qid) {
            const resp = await fetch(`/api/duplicates/merge/${qid}`, {method: 'POST'});
            return await resp.json();
        }

        // ============ Polling ============
        function startPolling(bookId) {
            stopPolling();
            pollingInterval = setInterval(async () => {
                const status = await getExtractionStatus(bookId);
                updateProgress(status);

                if (status.status === 'completed' || status.status === 'error') {
                    stopPolling();
                    fetchBooks();
                    if (status.status === 'completed') {
                        showResults(bookId);
                    }
                }
            }, 2000);
        }

        function stopPolling() {
            if (pollingInterval) {
                clearInterval(pollingInterval);
                pollingInterval = null;
            }
        }

        // ============ Main Tab Switch ============
        function switchMainTab(tab) {
            currentMainTab = tab;
            document.querySelectorAll('.main-tab').forEach(t => t.classList.remove('active'));
            document.querySelector(`.main-tab[onclick*="${tab}"]`).classList.add('active');

            document.querySelectorAll('.tab-content').forEach(c => c.classList.remove('active'));
            document.getElementById(`${tab}Tab`).classList.add('active');

            if (tab === 'matching') {
                loadExtractedBooks();
            } else if (tab === 'duplicates') {
                loadDuplicates();
            }
        }

        // ============ UI ============
        function switchTab(tab) {
            currentTab = tab;
            document.querySelectorAll('.tabs .tab').forEach(t => t.classList.remove('active'));
            document.querySelector(`.tab[onclick*="${tab}"]`).classList.add('active');
            renderBookList();
        }

        function updateSummary() {
            const summary = books.summary || {};
            document.getElementById('totalBooks').textContent = summary.total_unique_books || '-';

            // Count extracted
            let extracted = 0;
            const data = currentTab === 'category' ? books.by_category : books.by_servant;
            for (const cat of Object.values(data || {})) {
                for (const book of cat.books || []) {
                    if (book.status === 'done') extracted++;
                }
            }
            document.getElementById('totalExtracted').textContent = extracted;
            document.getElementById('matchingBadge').textContent = extracted;
        }

        function renderBookList() {
            const container = document.getElementById('bookList');
            const data = currentTab === 'category' ? books.by_category : books.by_servant;

            if (!data || Object.keys(data).length === 0) {
                container.innerHTML = '<div class="empty-state">No books loaded</div>';
                return;
            }

            let html = '';
            let totalBooks = 0;

            // Sort categories
            const sortedCategories = Object.entries(data).sort((a, b) => {
                const order = ['Epic-Greek', 'Epic-India', 'Epic-Norse', 'Epic-Anglo', 'Epic-Mesopotamia',
                               'Arthurian', 'Celtic', 'Charlemagne', 'Classical', 'Literature', 'History', 'Mythology'];
                const aIdx = order.indexOf(a[0]);
                const bIdx = order.indexOf(b[0]);
                if (aIdx >= 0 && bIdx >= 0) return aIdx - bIdx;
                if (aIdx >= 0) return -1;
                if (bIdx >= 0) return 1;
                return (b[1].count || 0) - (a[1].count || 0);
            });

            for (const [category, catData] of sortedCategories) {
                const bookList = catData.books || [];
                totalBooks += bookList.length;

                html += `<div class="category-group">
                    <h3 onclick="toggleCategory(this)">
                        ${catData.description || category}
                        <span class="count">${bookList.length}</span>
                    </h3>
                    <div class="book-list">`;

                for (const book of bookList) {
                    const statusClass = book.extraction_status === 'running' ? 'extracting' : book.status;
                    const selected = currentBook?.id === book.id ? 'selected' : '';

                    html += `<div class="book-item ${statusClass} ${selected}"
                                  onclick="selectBook('${category}', '${book.id}')">
                        <div class="book-title" title="${book.title}">${book.title}</div>
                        <span class="book-status ${statusClass}">${statusClass}</span>
                    </div>`;
                }
                html += '</div></div>';
            }

            container.innerHTML = html;
            document.getElementById('bookCount').textContent = totalBooks;
        }

        function toggleCategory(el) {
            el.parentElement.classList.toggle('collapsed');
        }

        function selectBook(category, bookId) {
            const data = currentTab === 'category' ? books.by_category : books.by_servant;
            const catData = data[category];
            currentBook = catData.books.find(b => b.id === bookId);
            currentBook.category = category;

            renderBookList();
            renderBookDetail();
            showResults(bookId);
        }

        async function renderBookDetail() {
            const container = document.getElementById('bookDetail');
            if (!currentBook) {
                container.innerHTML = '<div class="empty-state">Select a book</div>';
                return;
            }

            const isRunning = currentBook.extraction_status === 'running';
            const isDone = currentBook.status === 'done';

            let preview = '';
            try {
                const data = await getContentPreview(currentBook.path);
                if (data.preview) {
                    preview = data.preview.substring(0, 800) + '...';
                }
            } catch (e) {}

            container.innerHTML = `
                <div class="book-detail">
                    <h3>${currentBook.title}</h3>
                    <div class="book-meta">
                        <div><label>ZIM Path:</label> ${currentBook.path}</div>
                        <div><label>Category:</label> ${currentBook.category}</div>
                        ${currentBook.query ? `<div><label>Search Query:</label> ${currentBook.query}</div>` : ''}
                        <div><label>Status:</label> ${currentBook.status}</div>
                    </div>

                    <div class="action-buttons">
                        <button class="btn-primary"
                                onclick="handleExtract()"
                                ${isRunning ? 'disabled' : ''}>
                            ${isDone ? 'Re-Extract' : 'Start Extraction'}
                        </button>
                        ${isRunning ? `
                            <button class="btn-danger" onclick="cancelExtraction('${currentBook.id}')">
                                Cancel
                            </button>
                        ` : ''}
                        ${isDone ? `
                            <button class="btn-match" onclick="goToMatching('${currentBook.id}')">
                                &#128279; Match Entities
                            </button>
                        ` : ''}
                        <button class="btn-secondary" onclick="showPreview()">Preview Content</button>
                    </div>

                    <div class="progress-container" id="progressContainer" style="display: ${isRunning ? 'block' : 'none'}">
                        <div class="progress-bar">
                            <div class="progress-fill" id="progressFill" style="width: 0%"></div>
                        </div>
                        <div class="progress-text" id="progressText">Starting...</div>
                    </div>

                    <div id="previewContainer" style="display: none;">
                        <h4 style="color: #888; font-size: 0.8rem; margin-bottom: 8px;">Content Preview</h4>
                        <div class="content-preview" id="contentPreview">${preview || 'Loading...'}</div>
                    </div>
                </div>
            `;

            if (isRunning) {
                startPolling(currentBook.id);
            }
        }

        function goToMatching(bookId) {
            switchMainTab('matching');
            setTimeout(() => selectMatchBook(bookId), 100);
        }

        async function showPreview() {
            const container = document.getElementById('previewContainer');
            const previewEl = document.getElementById('contentPreview');

            if (container.style.display === 'none') {
                container.style.display = 'block';
                if (!previewEl.textContent || previewEl.textContent === 'Loading...') {
                    const data = await getContentPreview(currentBook.path);
                    previewEl.textContent = data.preview || 'No content available';
                }
            } else {
                container.style.display = 'none';
            }
        }

        function updateProgress(status) {
            const progressContainer = document.getElementById('progressContainer');
            const progressFill = document.getElementById('progressFill');
            const progressText = document.getElementById('progressText');

            if (!progressContainer) return;

            progressContainer.style.display = 'block';
            const percent = status.total > 0 ? (status.progress / status.total * 100) : 0;
            progressFill.style.width = `${percent}%`;
            progressFill.textContent = `${percent.toFixed(0)}%`;
            progressText.textContent = `${status.progress} / ${status.total} chunks | P:${status.persons_count} L:${status.locations_count} E:${status.events_count}`;
        }

        async function showResults(bookId) {
            const container = document.getElementById('resultsPanel');
            const results = await getResults(bookId);

            if (results.error) {
                container.innerHTML = '<div class="empty-state">No extraction results yet.<br>Click "Start Extraction" to begin.</div>';
                return;
            }

            const persons = results.persons || [];
            const locations = results.locations || [];
            const events = results.events || [];

            const elapsed = results.elapsed_seconds ? `${(results.elapsed_seconds/60).toFixed(1)} min` : '-';

            container.innerHTML = `
                <div class="stats-grid">
                    <div class="stat-box">
                        <div class="stat-value">${persons.length}</div>
                        <div class="stat-label">Persons</div>
                    </div>
                    <div class="stat-box">
                        <div class="stat-value">${locations.length}</div>
                        <div class="stat-label">Locations</div>
                    </div>
                    <div class="stat-box">
                        <div class="stat-value">${events.length}</div>
                        <div class="stat-label">Events</div>
                    </div>
                </div>

                <div style="font-size: 0.7rem; color: #666; margin-bottom: 15px; text-align: center;">
                    ${results.chunks_processed}/${results.total_chunks} chunks | ${elapsed}
                </div>

                <div class="results-section">
                    <h4>Persons <span>${persons.length}</span></h4>
                    <div class="entity-list">
                        ${persons.slice(0, 80).map(p => `<span class="entity-item">${p}</span>`).join('')}
                        ${persons.length > 80 ? `<span class="entity-item" style="background:#4a3a1a;">+${persons.length - 80} more</span>` : ''}
                    </div>
                </div>

                <div class="results-section">
                    <h4>Locations <span>${locations.length}</span></h4>
                    <div class="entity-list">
                        ${locations.slice(0, 40).map(l => `<span class="entity-item">${l}</span>`).join('')}
                        ${locations.length > 40 ? `<span class="entity-item" style="background:#4a3a1a;">+${locations.length - 40} more</span>` : ''}
                    </div>
                </div>

                <div class="results-section">
                    <h4>Events <span>${events.length}</span></h4>
                    <div class="entity-list">
                        ${events.slice(0, 25).map(e => `<span class="entity-item">${e}</span>`).join('')}
                        ${events.length > 25 ? `<span class="entity-item" style="background:#4a3a1a;">+${events.length - 25} more</span>` : ''}
                    </div>
                </div>
            `;
        }

        async function handleExtract() {
            if (!currentBook) return;

            await startExtraction(currentBook.id, currentBook.path, currentBook.title);

            currentBook.extraction_status = 'running';
            renderBookDetail();
        }

        // ============ Matching Tab ============
        async function loadExtractedBooks() {
            const container = document.getElementById('extractedList');
            const results = await fetch('/api/results').then(r => r.json());

            if (!results || results.length === 0) {
                container.innerHTML = '<div class="empty-state">No extracted books yet</div>';
                document.getElementById('extractedCount').textContent = '0';
                return;
            }

            document.getElementById('extractedCount').textContent = results.length;

            let html = '';
            for (const book of results) {
                const matchStatus = await getMatchStatus(book.book_id).catch(() => ({error: true}));
                const statusClass = matchStatus.status === 'completed' ? 'matched' : 'done';
                const statusText = matchStatus.status === 'completed' ? 'matched' : 'extracted';

                html += `<div class="book-item ${statusClass} ${currentMatchBook?.book_id === book.book_id ? 'selected' : ''}"
                              onclick="selectMatchBook('${book.book_id}')">
                    <div class="book-title" title="${book.title}">${book.title}</div>
                    <span class="book-status ${statusClass}">${statusText}</span>
                </div>`;
            }

            container.innerHTML = html;
        }

        async function selectMatchBook(bookId) {
            currentMatchBook = { book_id: bookId };

            // Reload list to update selection
            const results = await fetch('/api/results').then(r => r.json());
            currentMatchBook = results.find(r => r.book_id === bookId) || currentMatchBook;

            loadExtractedBooks();
            renderMatchingDetail();
            showMatchResults(bookId);
        }

        async function renderMatchingDetail() {
            const container = document.getElementById('matchingDetail');
            if (!currentMatchBook) {
                container.innerHTML = '<div class="empty-state">Select an extracted book</div>';
                return;
            }

            const extraction = await getResults(currentMatchBook.book_id);
            const matchStatus = await getMatchStatus(currentMatchBook.book_id).catch(() => ({error: true}));

            const isMatching = matchStatus.status === 'running';
            const isMatched = matchStatus.status === 'completed';

            const totalEntities = (extraction.persons?.length || 0) + (extraction.locations?.length || 0) + (extraction.events?.length || 0);

            container.innerHTML = `
                <div class="book-detail">
                    <h3>${extraction.title || currentMatchBook.book_id}</h3>
                    <div class="book-meta">
                        <div><label>Persons:</label> ${extraction.persons?.length || 0}</div>
                        <div><label>Locations:</label> ${extraction.locations?.length || 0}</div>
                        <div><label>Events:</label> ${extraction.events?.length || 0}</div>
                        <div><label>Total:</label> ${totalEntities} entities</div>
                    </div>

                    <div class="action-buttons">
                        <button class="btn-match"
                                onclick="handleMatch()"
                                ${isMatching ? 'disabled' : ''}>
                            ${isMatched ? '&#8635; Re-Match' : '&#128279; Start Matching'}
                        </button>
                        ${isMatching ? `
                            <button class="btn-danger" onclick="cancelMatch('${currentMatchBook.book_id}')">
                                Cancel
                            </button>
                        ` : ''}
                    </div>

                    <div class="progress-container" id="matchProgressContainer" style="display: ${isMatching ? 'block' : 'none'}">
                        <div class="progress-bar">
                            <div class="progress-fill" id="matchProgressFill" style="width: 0%"></div>
                        </div>
                        <div class="progress-text" id="matchProgressText">Starting...</div>
                    </div>

                    ${isMatched ? `
                        <div style="margin-top:15px; font-size:0.8rem; color:#888;">
                            <div>&#10003; Matched: ${matchStatus.matched_count || 0}</div>
                            <div>&#10067; New: ${matchStatus.new_count || 0}</div>
                            <div>&#128260; Merged: ${matchStatus.merged_count || 0}</div>
                        </div>
                    ` : ''}
                </div>
            `;

            if (isMatching) {
                startMatchPolling(currentMatchBook.book_id);
            }
        }

        let matchPolling = null;
        function startMatchPolling(bookId) {
            if (matchPolling) clearInterval(matchPolling);
            matchPolling = setInterval(async () => {
                const status = await getMatchStatus(bookId);
                updateMatchProgress(status);

                if (status.status === 'completed' || status.status === 'error') {
                    clearInterval(matchPolling);
                    matchPolling = null;
                    renderMatchingDetail();
                    showMatchResults(bookId);
                    loadExtractedBooks();
                }
            }, 2000);
        }

        function updateMatchProgress(status) {
            const container = document.getElementById('matchProgressContainer');
            const fill = document.getElementById('matchProgressFill');
            const text = document.getElementById('matchProgressText');

            if (!container) return;

            container.style.display = 'block';
            const percent = status.total > 0 ? (status.progress / status.total * 100) : 0;
            fill.style.width = `${percent}%`;
            fill.textContent = `${percent.toFixed(0)}%`;
            text.textContent = `${status.progress} / ${status.total} entities | M:${status.matched_count} N:${status.new_count}`;
        }

        async function handleMatch() {
            if (!currentMatchBook) return;
            await startMatching(currentMatchBook.book_id);
            renderMatchingDetail();
        }

        async function cancelMatch(bookId) {
            await fetch(`/api/match/cancel/${bookId}`, {method: 'POST'});
            if (matchPolling) clearInterval(matchPolling);
            renderMatchingDetail();
        }

        async function showMatchResults(bookId) {
            const container = document.getElementById('matchResultsPanel');
            const results = await getMatchResults(bookId);

            if (results.error) {
                container.innerHTML = '<div class="empty-state">No match results yet.<br>Click "Start Matching" to begin.</div>';
                return;
            }

            const matched = results.matched || [];
            const newEntities = results.new || [];
            const merged = results.merged || [];

            container.innerHTML = `
                <div class="stats-grid">
                    <div class="stat-box">
                        <div class="stat-value" style="color:#6f6;">${matched.length}</div>
                        <div class="stat-label">Matched</div>
                    </div>
                    <div class="stat-box">
                        <div class="stat-value" style="color:#fa0;">${newEntities.length}</div>
                        <div class="stat-label">New</div>
                    </div>
                    <div class="stat-box">
                        <div class="stat-value" style="color:#a4f;">${merged.length}</div>
                        <div class="stat-label">Merged</div>
                    </div>
                </div>

                <div class="results-section">
                    <h4>Matched <span>${matched.length}</span></h4>
                    <div style="max-height:200px; overflow-y:auto;">
                        ${matched.slice(0, 30).map(m => `
                            <div class="match-result-item">
                                <span class="name">${m.name}</span>
                                <span class="method">${m.method}</span>
                                <div class="details">${m.entity_type} #${m.entity_id} (${(m.confidence * 100).toFixed(0)}%)</div>
                            </div>
                        `).join('')}
                        ${matched.length > 30 ? `<div style="color:#888;text-align:center;padding:10px;">+${matched.length - 30} more</div>` : ''}
                    </div>
                </div>

                <div class="results-section">
                    <h4>New Entities <span>${newEntities.length}</span></h4>
                    <div style="max-height:150px; overflow-y:auto;">
                        ${newEntities.slice(0, 20).map(n => `
                            <div class="match-result-item new">
                                <span class="name">${n.name}</span>
                                <div class="details">${n.entity_type}${n.wikidata_qid ? ` | QID: ${n.wikidata_qid}` : ''}</div>
                            </div>
                        `).join('')}
                        ${newEntities.length > 20 ? `<div style="color:#888;text-align:center;padding:10px;">+${newEntities.length - 20} more</div>` : ''}
                    </div>
                </div>

                ${merged.length > 0 ? `
                    <div class="results-section">
                        <h4>Merged Duplicates <span>${merged.length}</span></h4>
                        <div style="max-height:100px; overflow-y:auto;">
                            ${merged.map(m => `
                                <div class="match-result-item merged">
                                    <span class="name">${m.name}</span>
                                    <div class="details">${m.entity_type} #${m.entity_id}</div>
                                </div>
                            `).join('')}
                        </div>
                    </div>
                ` : ''}
            `;
        }

        // ============ Duplicates Tab ============
        async function loadDuplicates() {
            const status = await getDuplicateStatus();
            const top = await getTopDuplicates();

            document.getElementById('totalDuplicates').textContent = status.duplicate_qids || '-';
            document.getElementById('duplicatesBadge').textContent = status.duplicate_qids || '0';

            // Status
            document.getElementById('dupTotal').textContent = (status.total_persons || 0).toLocaleString();
            document.getElementById('dupQids').textContent = (status.duplicate_qids || 0).toLocaleString();
            document.getElementById('dupMerged').textContent = (status.merged_aliases || 0).toLocaleString();

            // Recent merges
            const recentContainer = document.getElementById('recentMerges');
            const recentMerges = status.recent_merges || [];
            if (recentMerges.length > 0) {
                recentContainer.innerHTML = recentMerges.map(m => `
                    <div class="match-result-item merged">
                        <span class="name">${m.name}</span>
                        <div class="details">${m.alias_count} aliases merged</div>
                    </div>
                `).join('');
            } else {
                recentContainer.innerHTML = '<div class="empty-state">No merges yet</div>';
            }

            // Top duplicates
            const topContainer = document.getElementById('topDuplicates');
            const duplicates = top.duplicates || [];
            if (duplicates.length > 0) {
                topContainer.innerHTML = duplicates.map(d => `
                    <div class="dup-item">
                        <div style="flex:1;">
                            <div><span class="qid">${d.wikidata_id}</span> <span class="count">${d.cnt}x</span></div>
                            <div class="names">${(d.names || []).slice(0, 5).join(', ')}${d.names?.length > 5 ? '...' : ''}</div>
                        </div>
                        <button class="btn-merge" onclick="handleMerge('${d.wikidata_id}')">Merge</button>
                    </div>
                `).join('');
            } else {
                topContainer.innerHTML = '<div class="empty-state">No duplicates found! &#127881;</div>';
            }
        }

        async function handleMerge(qid) {
            if (!confirm(`Merge all records with QID ${qid}?`)) return;

            const result = await mergeDuplicate(qid);
            if (result.error) {
                alert('Error: ' + result.error);
            } else {
                alert(`Merged ${result.merged_count} records into "${result.primary_name}"`);
                loadDuplicates();
            }
        }

        // ============ Queue Control ============
        let queuePolling = null;

        async function checkQueueStatus() {
            try {
                const resp = await fetch('/api/queue/status');
                const data = await resp.json();
                updateQueueUI(data);
                return data;
            } catch (e) {
                console.error('Queue status error:', e);
                return null;
            }
        }

        function updateQueueUI(status) {
            const badge = document.getElementById('queueStatusBadge');
            const startBtn = document.getElementById('queueStartBtn');
            const pauseBtn = document.getElementById('queuePauseBtn');
            const stopBtn = document.getElementById('queueStopBtn');
            const modelSelect = document.getElementById('modelSelect');
            const progress = document.getElementById('queueProgress');
            const progressFill = document.getElementById('queueProgressFill');
            const progressText = document.getElementById('queueProgressText');
            const currentBookEl = document.getElementById('queueCurrentBook');
            const timeInfo = document.getElementById('queueTimeInfo');

            const chunkProgress = document.getElementById('chunkProgress');
            const chunkProgressFill = document.getElementById('chunkProgressFill');
            const chunkText = document.getElementById('chunkText');
            const chunkSpeed = document.getElementById('chunkSpeed');
            const bookElapsed = document.getElementById('bookElapsed');

            if (status.running) {
                badge.textContent = status.paused ? 'Paused' : 'Running';
                badge.className = 'queue-status ' + (status.paused ? 'paused' : 'running');
                startBtn.style.display = 'none';
                pauseBtn.style.display = 'inline-block';
                pauseBtn.textContent = status.paused ? 'Resume' : 'Pause';
                stopBtn.style.display = 'inline-block';
                modelSelect.disabled = true;
                progress.style.display = 'block';

                const percent = status.total > 0 ? ((status.completed / status.total) * 100) : 0;
                progressFill.style.width = `${percent}%`;
                progressText.textContent = `${status.completed} / ${status.total} books (${percent.toFixed(1)}%)`;

                if (status.current_book) {
                    currentBookEl.textContent = status.current_book.title.substring(0, 40) + '...';
                } else {
                    currentBookEl.textContent = '-';
                }

                if (status.elapsed_seconds > 0 && status.completed > 0) {
                    const avgTime = status.elapsed_seconds / status.completed;
                    const remaining = status.total - status.completed;
                    const eta = (avgTime * remaining) / 3600;
                    timeInfo.textContent = `ETA: ${eta.toFixed(1)}h`;
                }

                if (status.current_chunk !== undefined && status.total_chunks > 0) {
                    chunkProgress.style.display = 'block';
                    const chunkPercent = (status.current_chunk / status.total_chunks) * 100;
                    chunkProgressFill.style.width = `${chunkPercent}%`;
                    chunkText.textContent = `Chunk ${status.current_chunk} / ${status.total_chunks}`;

                    if (status.book_elapsed_seconds) {
                        const mins = Math.floor(status.book_elapsed_seconds / 60);
                        const secs = Math.floor(status.book_elapsed_seconds % 60);
                        bookElapsed.textContent = `${mins}m ${secs}s`;

                        if (status.current_chunk > 0 && status.book_elapsed_seconds > 0) {
                            const chunksPerMin = (status.current_chunk / status.book_elapsed_seconds) * 60;
                            chunkSpeed.textContent = `${chunksPerMin.toFixed(1)} chunks/min`;
                        }
                    }
                } else {
                    chunkProgress.style.display = 'none';
                }

                if (!queuePolling) {
                    queuePolling = setInterval(checkQueueStatus, 3000);
                }
            } else {
                badge.textContent = 'Stopped';
                badge.className = 'queue-status';
                startBtn.style.display = 'inline-block';
                pauseBtn.style.display = 'none';
                stopBtn.style.display = 'none';
                modelSelect.disabled = false;
                progress.style.display = 'none';
                chunkProgress.style.display = 'none';

                if (queuePolling) {
                    clearInterval(queuePolling);
                    queuePolling = null;
                }
            }
        }

        async function startQueue() {
            const model = document.getElementById('modelSelect').value;

            if (model !== 'ollama' && !confirm(`Using ${model} will cost approximately $15-257. Continue?`)) {
                return;
            }

            const resp = await fetch('/api/queue/start', {
                method: 'POST',
                headers: {'Content-Type': 'application/json'},
                body: JSON.stringify({model})
            });

            const data = await resp.json();
            if (data.error) {
                alert(data.message || data.error);
                return;
            }

            checkQueueStatus();
            fetchBooks();
        }

        async function togglePause() {
            const status = await checkQueueStatus();
            if (status.paused) {
                await fetch('/api/queue/resume', {method: 'POST'});
            } else {
                await fetch('/api/queue/pause', {method: 'POST'});
            }
            checkQueueStatus();
        }

        async function stopQueue() {
            if (!confirm('Stop the queue? Current book will be cancelled.')) {
                return;
            }
            await fetch('/api/queue/stop', {method: 'POST'});
            checkQueueStatus();
            fetchBooks();
        }

        // ============ Init ============
        async function init() {
            await Promise.all([checkOllama(), checkZim()]);
            await fetchBooks();
            await checkQueueStatus();
            await loadDuplicates();

            setInterval(() => {
                checkOllama();
                checkZim();
            }, 30000);
        }

        init();

        // Speed control buttons
        async function setSpeed(mode) {
            try {
                const resp = await fetch(`/api/speed/${mode}`, { method: 'POST' });
                const data = await resp.json();
                updateSpeedButtons(data.mode);
            } catch (e) {
                console.error('Speed change failed:', e);
            }
        }

        function updateSpeedButtons(activeMode) {
            document.querySelectorAll('.speed-btn').forEach(btn => {
                btn.classList.toggle('active', btn.dataset.speed === activeMode);
            });
        }

        document.querySelectorAll('.speed-btn').forEach(btn => {
            btn.addEventListener('click', () => setSpeed(btn.dataset.speed));
        });

        fetch('/api/speed').then(r => r.json()).then(data => updateSpeedButtons(data.mode));

        // ============ Statistics Modal ============
        async function openStats() {
            document.getElementById('statsModal').classList.add('active');
            document.getElementById('statsContent').innerHTML = '<div style="text-align:center;padding:40px;color:#888;">Loading statistics...</div>';
            await loadStats();
        }

        function closeStats() {
            document.getElementById('statsModal').classList.remove('active');
        }

        function closeStatsModal(event) {
            if (event.target === document.getElementById('statsModal')) {
                closeStats();
            }
        }

        async function loadStats() {
            try {
                const [statsResp, historyResp] = await Promise.all([
                    fetch('/api/stats'),
                    fetch('/api/stats/history?limit=50')
                ]);

                const stats = await statsResp.json();
                const history = await historyResp.json();

                renderStats(stats, history);
            } catch (e) {
                document.getElementById('statsContent').innerHTML = `
                    <div style="text-align:center;padding:40px;color:#f66;">
                        Error loading statistics: ${e.message}
                    </div>
                `;
            }
        }

        function renderStats(stats, history) {
            const container = document.getElementById('statsContent');

            const recentBooks = history.recent_50 || [];
            const totalFiles = history.total_files || 0;

            let validBooks = recentBooks.filter(b => b.duration_min && b.duration_min < 60);
            let totalDuration = 0;
            let totalSize = 0;
            let avgSpeedSum = 0;

            for (const book of validBooks) {
                totalDuration += book.duration_min || 0;
                totalSize += book.size_kb || 0;
                avgSpeedSum += book.speed_kb_per_min || 0;
            }

            const avgSpeed = validBooks.length > 0 ? (avgSpeedSum / validBooks.length).toFixed(1) : '-';

            let speedTrend = 'stable';
            let speedTrendClass = '';
            if (validBooks.length >= 10) {
                const recent5 = validBooks.slice(0, 5);
                const older5 = validBooks.slice(5, 10);

                const recentAvg = recent5.reduce((s, b) => s + (b.speed_kb_per_min || 0), 0) / 5;
                const olderAvg = older5.reduce((s, b) => s + (b.speed_kb_per_min || 0), 0) / 5;

                if (olderAvg > 0) {
                    const change = ((recentAvg - olderAvg) / olderAvg) * 100;
                    if (change > 10) {
                        speedTrend = `+${change.toFixed(0)}%`;
                        speedTrendClass = 'good';
                    } else if (change < -10) {
                        speedTrend = `${change.toFixed(0)}%`;
                        speedTrendClass = 'bad';
                    }
                }
            }

            const totalHours = (totalDuration / 60).toFixed(1);
            const totalSizeMB = (totalSize / 1024).toFixed(1);

            container.innerHTML = `
                <div class="stats-overview">
                    <div class="stats-card">
                        <div class="value">${totalFiles}</div>
                        <div class="label">Total Extracted</div>
                    </div>
                    <div class="stats-card ${speedTrendClass}">
                        <div class="value">${avgSpeed}</div>
                        <div class="label">KB/min (Avg)</div>
                    </div>
                    <div class="stats-card">
                        <div class="value">${totalHours}h</div>
                        <div class="label">Total Time</div>
                    </div>
                    <div class="stats-card ${speedTrendClass}">
                        <div class="value">${speedTrend}</div>
                        <div class="label">Speed Trend</div>
                    </div>
                </div>

                <h3 style="color:#888;font-size:0.9rem;margin-bottom:15px;">Recent Extractions (${recentBooks.length} of ${totalFiles})</h3>

                <table class="history-table">
                    <thead>
                        <tr>
                            <th></th>
                            <th>Book</th>
                            <th>Size</th>
                            <th>Duration</th>
                            <th>Speed</th>
                            <th>Completed</th>
                        </tr>
                    </thead>
                    <tbody>
                        ${recentBooks.map(book => {
                            const speed = book.speed_kb_per_min || 0;
                            const speedClass = speed >= 10 ? 'fast' : speed >= 5 ? 'medium' : 'slow';

                            let duration = '-';
                            if (book.duration_min) {
                                if (book.duration_min >= 60) {
                                    duration = '<span style="color:#888;">pause</span>';
                                } else {
                                    const mins = Math.floor(book.duration_min);
                                    const secs = Math.floor((book.duration_min % 1) * 60);
                                    duration = `${mins}m ${secs}s`;
                                }
                            }

                            const size = book.size_kb ? `${book.size_kb.toFixed(0)} KB` : '-';

                            const completed = book.completed_at ?
                                new Date(book.completed_at).toLocaleString('ko-KR', {
                                    month: '2-digit', day: '2-digit',
                                    hour: '2-digit', minute: '2-digit'
                                }) : '-';

                            const bookName = (book.name || '').replace(/_/g, ' ');

                            return `
                                <tr>
                                    <td><span class="speed-indicator speed-${speedClass}"></span></td>
                                    <td title="${bookName}">${bookName.substring(0, 40)}${bookName.length > 40 ? '...' : ''}</td>
                                    <td>${size}</td>
                                    <td>${duration}</td>
                                    <td>${speed > 0 ? speed.toFixed(1) + ' KB/min' : '-'}</td>
                                    <td>${completed}</td>
                                </tr>
                            `;
                        }).join('')}
                    </tbody>
                </table>

                <div style="margin-top:20px;text-align:center;color:#666;font-size:0.75rem;">
                    Total: ${totalSizeMB} MB processed in ${totalHours} hours
                    <br><br>
                    <button class="btn-secondary" onclick="loadStats()">&#8635; Refresh</button>
                </div>
            `;
        }

        document.addEventListener('keydown', (e) => {
            if (e.key === 'Escape') closeStats();
        });

        // ============ Auto Tab Switch ============
        let currentAutoTab = 'extraction';

        function switchAutoTab(tab) {
            currentAutoTab = tab;
            document.querySelectorAll('.auto-tab').forEach(t => t.classList.remove('active'));
            document.querySelector(`.auto-tab[data-tab="${tab}"]`).classList.add('active');

            document.querySelectorAll('.auto-content').forEach(c => c.classList.remove('active'));
            document.getElementById(`auto${tab.charAt(0).toUpperCase() + tab.slice(1)}Content`).classList.add('active');

            updateModelInfo(tab);
        }

        function updateModelInfo(tab) {
            const info = document.getElementById('currentModelInfo');
            if (tab === 'extraction') {
                info.textContent = 'llama3.1:8b (Ollama)';
            } else if (tab === 'matching') {
                info.textContent = 'text-embedding-3-small + gpt-5-mini';
            } else if (tab === 'duplicates') {
                info.textContent = 'QID Merge (DB)';
            }
        }

        // ============ Auto Matching ============
        let autoMatchPolling = null;

        async function getUnmatchedCount() {
            try {
                const resp = await fetch('/api/auto/unmatched');
                const data = await resp.json();
                document.getElementById('unmatchedBadge').textContent = data.unmatched_count || 0;
                return data.unmatched_count || 0;
            } catch (e) {
                return 0;
            }
        }

        async function startAutoMatching() {
            const count = await getUnmatchedCount();
            if (count === 0) {
                alert('No unmatched books to process!');
                return;
            }

            if (!confirm(`Start matching ${count} unmatched books? This uses OpenAI API and may incur costs.`)) {
                return;
            }

            const resp = await fetch('/api/auto/start', {
                method: 'POST',
                headers: {'Content-Type': 'application/json'},
                body: JSON.stringify({mode: 'matching'})
            });

            const data = await resp.json();
            if (data.error) {
                alert(data.error);
                return;
            }

            startAutoMatchPolling();
        }

        function startAutoMatchPolling() {
            if (autoMatchPolling) clearInterval(autoMatchPolling);
            autoMatchPolling = setInterval(checkAutoStatus, 2000);
            checkAutoStatus();
        }

        async function checkAutoStatus() {
            try {
                const resp = await fetch('/api/auto/status');
                const data = await resp.json();
                updateAutoUI(data);

                if (!data.running && autoMatchPolling) {
                    clearInterval(autoMatchPolling);
                    autoMatchPolling = null;
                    getUnmatchedCount();
                    loadDuplicates();
                }
            } catch (e) {
                console.error('Auto status error:', e);
            }
        }

        function updateAutoUI(status) {
            if (status.mode === 'matching') {
                updateMatchingAutoUI(status);
            } else if (status.mode === 'duplicates') {
                updateDuplicatesAutoUI(status);
            }
        }

        function updateMatchingAutoUI(status) {
            const badge = document.getElementById('matchingStatusBadge');
            const startBtn = document.getElementById('matchingStartBtn');
            const pauseBtn = document.getElementById('matchingPauseBtn');
            const stopBtn = document.getElementById('matchingStopBtn');
            const progress = document.getElementById('matchingProgress');
            const progressFill = document.getElementById('matchingProgressFill');
            const progressText = document.getElementById('matchingProgressText');
            const currentBook = document.getElementById('matchingCurrentBook');
            const timeInfo = document.getElementById('matchingTimeInfo');

            if (status.running) {
                badge.textContent = status.paused ? 'Paused' : 'Running';
                badge.className = 'queue-status ' + (status.paused ? 'paused' : 'running');
                startBtn.style.display = 'none';
                pauseBtn.style.display = 'inline-block';
                pauseBtn.textContent = status.paused ? 'Resume' : 'Pause';
                stopBtn.style.display = 'inline-block';
                progress.style.display = 'block';

                const percent = status.total > 0 ? ((status.completed / status.total) * 100) : 0;
                progressFill.style.width = `${percent}%`;
                progressText.textContent = `${status.completed} / ${status.total} books`;
                currentBook.textContent = status.current_item ? status.current_item.substring(0, 30) + '...' : '-';

                if (status.elapsed_seconds > 0 && status.completed > 0) {
                    const avgTime = status.elapsed_seconds / status.completed;
                    const remaining = status.total - status.completed;
                    const eta = (avgTime * remaining) / 60;
                    timeInfo.textContent = `ETA: ${eta.toFixed(1)}m`;
                }
            } else {
                badge.textContent = 'Stopped';
                badge.className = 'queue-status';
                startBtn.style.display = 'inline-block';
                pauseBtn.style.display = 'none';
                stopBtn.style.display = 'none';
                progress.style.display = 'none';
            }
        }

        async function toggleAutoMatching() {
            const resp = await fetch('/api/auto/status');
            const status = await resp.json();

            if (status.paused) {
                await fetch('/api/auto/resume', {method: 'POST'});
            } else {
                await fetch('/api/auto/pause', {method: 'POST'});
            }
            checkAutoStatus();
        }

        async function stopAutoMatching() {
            if (!confirm('Stop auto-matching?')) return;
            await fetch('/api/auto/stop', {method: 'POST'});
            checkAutoStatus();
        }

        // ============ Auto Duplicates ============
        async function startAutoDuplicates() {
            const dupStatus = await getDuplicateStatus();
            const count = dupStatus.duplicate_qids || 0;

            if (count === 0) {
                alert('No duplicates to merge!');
                return;
            }

            if (!confirm(`Start merging ${count} duplicate QIDs?`)) {
                return;
            }

            const resp = await fetch('/api/auto/start', {
                method: 'POST',
                headers: {'Content-Type': 'application/json'},
                body: JSON.stringify({mode: 'duplicates'})
            });

            const data = await resp.json();
            if (data.error) {
                alert(data.error);
                return;
            }

            startAutoDupPolling();
        }

        let autoDupPolling = null;

        function startAutoDupPolling() {
            if (autoDupPolling) clearInterval(autoDupPolling);
            autoDupPolling = setInterval(checkAutoDupStatus, 1000);
            checkAutoDupStatus();
        }

        async function checkAutoDupStatus() {
            try {
                const resp = await fetch('/api/auto/status');
                const data = await resp.json();

                if (data.mode === 'duplicates') {
                    updateDuplicatesAutoUI(data);
                }

                if (!data.running && autoDupPolling) {
                    clearInterval(autoDupPolling);
                    autoDupPolling = null;
                    loadDuplicates();
                }
            } catch (e) {
                console.error('Auto dup status error:', e);
            }
        }

        function updateDuplicatesAutoUI(status) {
            const badge = document.getElementById('dupStatusBadge');
            const startBtn = document.getElementById('dupStartBtn');
            const pauseBtn = document.getElementById('dupPauseBtn');
            const stopBtn = document.getElementById('dupStopBtn');
            const progress = document.getElementById('dupProgress');
            const progressFill = document.getElementById('dupProgressFill');
            const progressText = document.getElementById('dupProgressText');
            const currentQid = document.getElementById('dupCurrentQid');
            const timeInfo = document.getElementById('dupTimeInfo');

            if (status.running) {
                badge.textContent = status.paused ? 'Paused' : 'Running';
                badge.className = 'queue-status ' + (status.paused ? 'paused' : 'running');
                startBtn.style.display = 'none';
                pauseBtn.style.display = 'inline-block';
                pauseBtn.textContent = status.paused ? 'Resume' : 'Pause';
                stopBtn.style.display = 'inline-block';
                progress.style.display = 'block';

                const percent = status.total > 0 ? ((status.completed / status.total) * 100) : 0;
                progressFill.style.width = `${percent}%`;
                progressText.textContent = `${status.completed} / ${status.total} QIDs merged`;
                currentQid.textContent = status.current_item || '-';

                if (status.elapsed_seconds > 0) {
                    const mins = Math.floor(status.elapsed_seconds / 60);
                    const secs = Math.floor(status.elapsed_seconds % 60);
                    timeInfo.textContent = `${mins}m ${secs}s`;
                }
            } else {
                badge.textContent = 'Stopped';
                badge.className = 'queue-status';
                startBtn.style.display = 'inline-block';
                pauseBtn.style.display = 'none';
                stopBtn.style.display = 'none';
                progress.style.display = 'none';
            }
        }

        async function toggleAutoDuplicates() {
            const resp = await fetch('/api/auto/status');
            const status = await resp.json();

            if (status.paused) {
                await fetch('/api/auto/resume', {method: 'POST'});
            } else {
                await fetch('/api/auto/pause', {method: 'POST'});
            }
            checkAutoDupStatus();
        }

        async function stopAutoDuplicates() {
            if (!confirm('Stop auto-duplicates?')) return;
            await fetch('/api/auto/stop', {method: 'POST'});
            checkAutoDupStatus();
        }

        // Update init to load badges
        const originalInit = init;
        init = async function() {
            await originalInit();
            await getUnmatchedCount();
            updateModelInfo('extraction');
        };
    </script>
</body>
</html>
